## 📌 Паттерн 1: **Singleton (Одиночка)**

### 🧠 Назначение:

Гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.

---

### ✅ Преимущества:

* Контроль над единственным экземпляром класса.
* Экономия ресурсов при повторном использовании.
* Удобно при управлении состоянием приложения (например, конфигурации, логгеры).

---

### ❌ Недостатки:

* Нарушает принцип единственной ответственности (SRP).
* Затрудняет написание unit-тестов (из-за глобального состояния).
* Может быть проблемой в многопоточной среде без синхронизации.
* Трудно расширяем (невозможно наследовать разные реализации одиночки).

---

### 🏗️ Структура классов

```
┌─────────────┐
│   Client    │
└────┬────────┘
     │
     ▼
┌──────────────┐
│  Singleton   │
│──────────────│
│ - instance   │  (статическое поле)
│ + getInstance│  (статический метод)
│ + operation  │
└──────────────┘
```

---

### 💻 Пример на C++

```cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mutex;

    // Приватный конструктор
    Singleton() {
        std::cout << "Singleton создан\n";
    }

public:
    // Запрет копирования
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton* getInstance() {
        std::lock_guard<std::mutex> lock(mutex);
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    void operation() {
        std::cout << "Операция Singleton\n";
    }
};

// Инициализация статических полей
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;

int main() {
    Singleton::getInstance()->operation();
    Singleton::getInstance()->operation();
}
```

---

### 🖼️ Иллюстративная схема:

```
┌────────────────────────┐
│       main()           │
└─────────┬──────────────┘
          │
          ▼
  Singleton::getInstance()
          │
          ▼
┌────────────────────────┐
│     Singleton (1x)     │
│ operation()            │
└────────────────────────┘
```

---

### ❓ Углубляющие вопросы:

1. Зачем делать конструктор класса Singleton приватным?
2. Что произойдет, если использовать Singleton без блокировки в многопоточной среде?
3. Почему Singleton считается антипаттерном в больших проектах?
4. Как реализовать ленивую инициализацию без утечек памяти?
5. Какие способы сделать Singleton потокобезопасным в C++11 и выше?
6. Как бы вы реализовали Singleton для использования в юнит-тестах?

---

## 🧩 Паттерн 1: **Singleton (Одиночка)**

### 🔍 Углубляющие вопросы и ответы

1. **Как гарантируется, что экземпляр создается только один раз?**

   * Используется статическая локальная переменная внутри функции `getInstance()`. Это обеспечивает ленивую и потокобезопасную инициализацию с C++11 и выше.

2. **Почему `delete` не вызывается в деструкторе?**

   * Экземпляр управляется системой, а не вручную. Уничтожение объекта происходит при завершении работы программы.

3. **Как избежать утечек памяти при использовании `new`?**

   * Используйте умные указатели (`std::unique_ptr` или `std::shared_ptr`), чтобы автоматически управлять временем жизни объекта.

4. **Как реализовать потокобезопасный Singleton?**

   * Используйте статическую локальную переменную, которая инициализируется при первом обращении к `getInstance()`. Это обеспечит потокобезопасность без необходимости использования мьютексов.

5. **Какой подход предпочтительнее: ленивый или ранний?**

   * Ленивый Singleton инициализируется при первом использовании, что экономит ресурсы, но может быть неэффективным в многопоточной среде. Ранний Singleton инициализируется при старте программы, что обеспечивает более предсказуемое поведение.

---

### 🧱 Расширенный пример на C++

```cpp
#include <iostream>
#include <memory>
#include <mutex>

class Singleton {
private:
    static std::unique_ptr<Singleton> instance;
    static std::mutex mtx;

    Singleton() { std::cout << "Singleton создан\n"; }

public:
    static Singleton* getInstance() {
        if (!instance) {
            std::lock_guard<std::mutex> lock(mtx);
            if (!instance) {
                instance.reset(new Singleton());
            }
        }
        return instance.get();
    }

    void showMessage() { std::cout << "Сообщение от Singleton\n"; }
};

std::unique_ptr<Singleton> Singleton::instance = nullptr;
std::mutex Singleton::mtx;

int main() {
    Singleton::getInstance()->showMessage();
    return 0;
}
```

---

### 🖼️ Схема

```
+---------------------+
|   Singleton         |
|---------------------|
| - instance          |
|---------------------|
| + getInstance()     |
| + showMessage()     |
+---------------------+
```

---

## ✅ Реализация Singleton на C++ (с комментариями)

```cpp
#include <iostream>

// Класс Singleton — гарантирует, что у него будет только один экземпляр.
class Singleton {
private:
    // Приватный конструктор — никто не сможет создать объект извне
    Singleton() {
        std::cout << "Singleton создан\n";
    }

    // Удаляем копирующий конструктор и оператор присваивания —
    // это запрещает копирование и клонирование объекта Singleton.
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    // Статическая функция, которая возвращает единственный экземпляр
    static Singleton& getInstance() {
        // Локальная статическая переменная создаётся один раз при первом вызове.
        // С C++11 это потокобезопасно.
        static Singleton instance;

        // Возвращаем ссылку на экземпляр
        return instance;
    }

    // Пример метода внутри Singleton
    void sayHello() {
        std::cout << "Привет из Singleton!\n";
    }
};

// Точка входа в программу
int main() {
    // Получаем ссылку на единственный экземпляр и вызываем метод
    Singleton& s1 = Singleton::getInstance();
    s1.sayHello();

    // Получаем ещё одну ссылку — это тот же объект
    Singleton& s2 = Singleton::getInstance();
    s2.sayHello();

    // Проверим, что это действительно один и тот же объект
    std::cout << "Адрес первого: " << &s1 << std::endl;
    std::cout << "Адрес второго: " << &s2 << std::endl;

    return 0;
}
```

---

## 🧠 Объяснение ключевых моментов:

| Элемент                                   | Объяснение                                                                                                  |
| ----------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| `private Singleton()`                     | Конструктор скрыт — никто не может создать объект напрямую.                                                 |
| `static Singleton& getInstance()`         | Возвращает **единственный экземпляр**. Создаёт его при первом вызове.                                       |
| `static Singleton instance;`              | Это и есть реализация **ленивой инициализации**: объект создаётся **только один раз**, когда реально нужен. |
| `static` внутри функции                   | С гарантией потокобезопасности начиная с **C++11**.                                                         |
| Удаление `copy constructor` и `operator=` | Защита от создания копий — Singleton должен существовать в **одном экземпляре**.                            |

---

## 🧪 Пример вывода:

```text
Singleton создан
Привет из Singleton!
Привет из Singleton!
Адрес первого: 0x558cbf6d5e20
Адрес второго: 0x558cbf6d5e20
```

Как видно — объект создаётся **только один раз**, и оба обращения возвращают **один и тот же адрес**.

---

Если нужно, могу показать также **ленивую инициализацию с указателем и контролем через `std::unique_ptr`**, или **thread-safe версию с `std::mutex` для C++98/03**.

