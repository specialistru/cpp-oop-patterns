## 📌 Паттерн 1: **Singleton (Одиночка)**

### 🧠 Назначение:

Гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.

---

### ✅ Преимущества:

* Контроль над единственным экземпляром класса.
* Экономия ресурсов при повторном использовании.
* Удобно при управлении состоянием приложения (например, конфигурации, логгеры).

---

### ❌ Недостатки:

* Нарушает принцип единственной ответственности (SRP).
* Затрудняет написание unit-тестов (из-за глобального состояния).
* Может быть проблемой в многопоточной среде без синхронизации.
* Трудно расширяем (невозможно наследовать разные реализации одиночки).

---

### 🏗️ Структура классов

```
┌─────────────┐
│   Client    │
└────┬────────┘
     │
     ▼
┌──────────────┐
│  Singleton   │
│──────────────│
│ - instance   │  (статическое поле)
│ + getInstance│  (статический метод)
│ + operation  │
└──────────────┘
```

---

### 💻 Пример на C++

```cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mutex;

    // Приватный конструктор
    Singleton() {
        std::cout << "Singleton создан\n";
    }

public:
    // Запрет копирования
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton* getInstance() {
        std::lock_guard<std::mutex> lock(mutex);
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    void operation() {
        std::cout << "Операция Singleton\n";
    }
};

// Инициализация статических полей
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex;

int main() {
    Singleton::getInstance()->operation();
    Singleton::getInstance()->operation();
}
```

---

### 🖼️ Иллюстративная схема:

```
┌────────────────────────┐
│       main()           │
└─────────┬──────────────┘
          │
          ▼
  Singleton::getInstance()
          │
          ▼
┌────────────────────────┐
│     Singleton (1x)     │
│ operation()            │
└────────────────────────┘
```

---

### ❓ Углубляющие вопросы:

1. Зачем делать конструктор класса Singleton приватным?
2. Что произойдет, если использовать Singleton без блокировки в многопоточной среде?
3. Почему Singleton считается антипаттерном в больших проектах?
4. Как реализовать ленивую инициализацию без утечек памяти?
5. Какие способы сделать Singleton потокобезопасным в C++11 и выше?
6. Как бы вы реализовали Singleton для использования в юнит-тестах?

---

## 🧩 Паттерн 1: **Singleton (Одиночка)**

### 🔍 Углубляющие вопросы и ответы

1. **Как гарантируется, что экземпляр создается только один раз?**

   * Используется статическая локальная переменная внутри функции `getInstance()`. Это обеспечивает ленивую и потокобезопасную инициализацию с C++11 и выше.

2. **Почему `delete` не вызывается в деструкторе?**

   * Экземпляр управляется системой, а не вручную. Уничтожение объекта происходит при завершении работы программы.

3. **Как избежать утечек памяти при использовании `new`?**

   * Используйте умные указатели (`std::unique_ptr` или `std::shared_ptr`), чтобы автоматически управлять временем жизни объекта.

4. **Как реализовать потокобезопасный Singleton?**

   * Используйте статическую локальную переменную, которая инициализируется при первом обращении к `getInstance()`. Это обеспечит потокобезопасность без необходимости использования мьютексов.

5. **Какой подход предпочтительнее: ленивый или ранний?**

   * Ленивый Singleton инициализируется при первом использовании, что экономит ресурсы, но может быть неэффективным в многопоточной среде. Ранний Singleton инициализируется при старте программы, что обеспечивает более предсказуемое поведение.

---

### 🧱 Расширенный пример на C++

```cpp
#include <iostream>
#include <memory>
#include <mutex>

class Singleton {
private:
    static std::unique_ptr<Singleton> instance;
    static std::mutex mtx;

    Singleton() { std::cout << "Singleton создан\n"; }

public:
    static Singleton* getInstance() {
        if (!instance) {
            std::lock_guard<std::mutex> lock(mtx);
            if (!instance) {
                instance.reset(new Singleton());
            }
        }
        return instance.get();
    }

    void showMessage() { std::cout << "Сообщение от Singleton\n"; }
};

std::unique_ptr<Singleton> Singleton::instance = nullptr;
std::mutex Singleton::mtx;

int main() {
    Singleton::getInstance()->showMessage();
    return 0;
}
```

---

### 🖼️ Схема

```
+---------------------+
|   Singleton         |
|---------------------|
| - instance          |
|---------------------|
| + getInstance()     |
| + showMessage()     |
+---------------------+
```

---
